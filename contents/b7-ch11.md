## Section 7: Composition vs Inheritance

While inheritance is powerful, it’s not always the best way to organize your
code. In many situations, **composition** — building classes by combining
smaller objects — is a better fit than building long chains of inheritance.

### What Is Composition?

Composition means that a class **has** other objects inside it, rather than
**is** another type of object. For example, a `Car` isn’t a `Wheel`, but a car
*has* wheels. That’s composition.

Let’s look at an example:

```python
class Engine:
    def start(self):
        print("Engine starts.")

class Car:
    def __init__(self):
        self.engine = Engine()  # composition: car *has* an engine

    def drive(self):
        self.engine.start()
        print("The car is moving.")
```

Here, `Car` doesn’t inherit from `Engine`. Instead, it **uses** an instance of
`Engine` to accomplish part of its job. This creates **looser coupling** between
parts of your code and makes things easier to maintain or reuse.  Loose coupling
means that components can be swapped out or worked on independently without
breaking other parts of the codebase.

### Inheritance vs Composition

| Inheritance                    | Composition                        |
| ------------------------------ | ---------------------------------- |
| “Is-a” relationship            | “Has-a” relationship               |
| Code reuse through subclassing | Code reuse through combining parts |
| Tightly coupled                | More loosely coupled               |
| Harder to refactor deeply      | Easier to swap components          |

Choose inheritance when:

* You want to model a natural hierarchy
* A subclass *really is* a type of the parent class

Choose composition when:

* You want flexibility or plug-and-play behavior
* Your objects don’t share a natural “is-a” relationship

> **Helpful Hint:**
> In real-world software, many developers favor **composition over inheritance**
> because it leads to more modular and testable code — especially as your
> programs grow.

You’ve now learned how to define classes, organize data and behavior, extend
functionality with inheritance, and design clean, modular programs with
composition.

