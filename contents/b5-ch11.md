## Section 5: Inheritance and Reuse

One of the most powerful ideas in object-oriented programming is **inheritance**
- the ability to create a new class based on an existing one. This allows you to
reuse code, avoid duplication, and create a hierarchy of related behaviors.

### Why Use Inheritance?

Remeember that Pet` class that works great for general pets? When we created the
Dog specialized class, it ignored that dogs are pets. It'd be nice to reuse the
Pet class for Dogs without rewriting all the attributes and methods. Inheritance
lets you do this easily.

### Creating a Subclass

To create a new class that *inherits* from an existing one, just include the
parent class name in parentheses:

```python
class Dog(Pet):
    def __init__(self, name, age, breed):
        super().__init__(name, "dog", age)
        self.breed = breed
```

The `super()` function lets the subclass call the parent class's `__init__()` to
avoid repeating code. It ensures that `name`, `species`, and `age` are set up
properly, just like in the base `Pet` class.

### Inherited Behavior

Your `Dog` class can now use all the methods defined in `Pet`, like `speak()` or
`celebrate_birthday()`, without redefining them.

```python
my_dog = Dog("Max", 4, "Labrador")
my_dog.speak()  # Max the dog says hello!
```

You can also add new behavior that’s specific to the subclass:

```python
    def fetch(self):
        print(f"{self.name} is fetching the ball!")
```

### Is-A Relationships

Inheritance models an **“is-a”** relationship. A `Dog` **is a** `Pet`. That
means anywhere your program expects a `Pet`, a `Dog` will also work. This makes
inheritance a great fit for building software that can handle general and
specific cases.

> **Helpful Hint:**
> You can chain inheritance further by creating subclasses of subclasses, but
> too many layers can get confusing. Use it thoughtfully.

