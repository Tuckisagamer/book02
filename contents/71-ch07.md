\newpage

# Chapter 7: Files

## Section 1: Why Files Matter

When a Python program ends, all of its variables disappear. If you store a list
of high scores, or a collection of contact information, or even a cool paragraph
of generated text — it’s all lost when the program finishes running.

To make data **persist** (stay around after the program ends), you need to save
it somewhere — and that’s where **files** come in.

### Your Variables Are Temporary

Let’s say you write this simple program:

```python
scores = [900, 720, 880]
print("High scores:", scores)
```

It runs. It prints the scores. But the moment the script finishes, the list is
gone. If you re-run the script, it resets the list back to `[900, 720, 880]`.

That’s fine for testing. But what if you want to add a new score each time
someone plays your game? Or remember a user’s preferences between sessions?

### Files Are Like Program Memory — That Stays

A **file** is like a notebook your program can write in. Instead of starting
over every time, you can read from the file at the beginning, update the
contents, and write the changes back at the end.

The flow looks like this:

```
START
  ↓
Open file → Load data → Modify data → Save file
  ↓
END
```

Once data is stored in a file:

* You can open it later
* Other programs can use it
* It lives outside the memory of the running Python program

This makes your programs **stateful** — they can remember what happened the last
time they ran.

### Common File Types

| File Type | Purpose                   | Example                               |
| --------- | ------------------------- | ------------------------------------- |
| `.txt`    | Plain text data           | Notes, logs, raw strings              |
| `.csv`    | Comma-separated values    | Table-style data like spreadsheets    |
| `.json`   | Structured key/value data | Dictionaries, objects, nested records |
| `.log`    | Program-generated logs    | Error logs, status messages           |

We’ll start with *plain text files* and then move into *JSON*, which is
especially useful for structured Python data like dictionaries and lists.

## A Real-World Example

Imagine you're building a to-do list app. Every time a user adds a task, you
want to save it. Here's how that works without and with a file:

### Without a file:

```python
tasks = []
tasks.append("Buy milk")
# User closes the app. All tasks are lost.
```

### With a file:

```python
# Load tasks from file (if it exists)
# Add new task
# Save updated list back to file
```

The user can open the app tomorrow, and their task will still be there. That’s
persistence.

### Helpful Hint:

> *Every serious program eventually needs a way to store its state.*
> Whether you’re making a game, a form, or a data analysis script — learning to
> read and write files is what turns your programs from *toys* into *tools*.

