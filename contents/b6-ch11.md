## Section 6: Method Overriding and Polymorphism

In object-oriented programming, it’s not enough to just inherit behavior —
sometimes you want to **change** it. Python lets you do this through
**method overriding** and supports **polymorphism**, a key concept that helps
you write flexible, reusable code.

### Method Overriding

If a subclass defines a method with the same name as one in its parent class,
Python uses the subclass’s version instead. This is called **overriding**.

Let’s say your `Pet` class has a `speak()` method:

```python
class Pet:
    def __init__(self, name, species, age):
        self.name = name
        self.species = species
        self.age = age

    def speak(self):
        print(f"{self.name} the {self.species} makes a sound.")
```

Now you want `Dog` to make a specific sound:

```python
class Dog(Pet):
    def __init__(self, name, age, breed):
        super().__init__(name, "dog", age)
        self.breed = breed

    def speak(self):
        print(f"{self.name} says woof!")
```

```python
generic = Pet("Whiskers", "cat", 4)
doggo = Dog("Buddy", 2, "Beagle")

generic.speak()  # Whiskers the cat makes a sound.
doggo.speak()    # Buddy says woof!
```

Same method name — different behavior, depending on the object.

### Polymorphism

**Polymorphism** means “many forms.” In programming, it allows different objects
to be treated the same way while still behaving according to their own class
definitions.

Example:

```python
pets = [
    Pet("Nemo", "fish", 1),
    Dog("Scout", 3, "Border Collie"),
    Dog("Barkley", 5, "Terrier")
]

for pet in pets:
    pet.speak()
```

Python doesn’t need to know the exact type of `pet`. As long as each object has
a `speak()` method, it can be called — this is **dynamic dispatch**, and it
makes your code more flexible.

> **Helpful Hint:**
> You can design your code to expect any object that implements certain methods,
> rather than checking types. This approach is known as *duck typing*: “If it
> walks like a duck and quacks like a duck, it’s a duck.”


